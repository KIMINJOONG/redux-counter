멀티카운터를 만들면서 불편한점
=================================
1. 액션을 만들때마다 세가지파일(액션타입, 액션생성함수, 리듀서)를 수정해야한다는점<br/>
2. 전개 연산자(...)와 slice함수로 배열 내부의 원소를 수정하는데 가독성이 낮다는 점<br/>
이런 불편한 점을 해결하여 더욱 편하게 리덕스를 사용하는 방법을 공부하자!<br/>
--------------------------------------
Immutable.js란?
===========================
자바스크립트에서 불변성 데이터를 다룰수 있도록 도와준다.
--------------------------
객체 불변성?
==========================
let a= 7; let b=7; let object1={a:1, b:2}; let object2= {a:1, b:2};<br/>
a===b = true가 출력 object1 === object2 는 false가 출력 <br/>
let object3 = object1 true가 출력<br/>
object3에 object1을 넣고 두값을 비교하면 true왜냐? 같은 객체를 가르키기 때문<br/>
object3.c = 3;<br/>
object1 === object3결과는?<br/>
true를 출력 그렇다면 obejct1의 값은? {a:1, b:2,c:3}이 되어있다.<br/>
object3에 c를 추가했는데 object1에도 c값이 생성되어있음<br/>
let array1 = [0,1,2,3,4,5]; let array2 = array1;<br/>
array2.push(5);<br/>
이렇게 array2에 5를 삽입하고, array1과 2를 비교하면? true를 반환<br/>
리액트 컴포넌트는 state또는 상위 컴포넌트에서 전달받은 props값이 변할때 리렌더링되는데,<br>
배열이나 객체를 집접 수정한다면 내부 값을 수정했을지라도 레퍼런스가 가리키는 곳은 같기때문에 똑같은 값으로 인식한다.<br/>
이런 이슈때문에 지금까지 여러층으로 구성된 객체 또는 배열을 업데이트 해야 할때, 전개 연산자(...)를 사용해서 기존 값을 가진 새객체 또는 배열을 만들었음.
--------------------------------
Immutable.js에서의 Map?
=============================
Imumutable의 Map은 객체 대신 사용하는 데이터 구조! 자바스크립트에 내장된 Map과는 다르다!<br/>
Immutable객체를 실제로 활용하거나 업데이트를 해야할때는 내장함수를 사용해야함!<br/>
.toJS()함수로 자바스크립트 객체로 변환해줘야한다.<br/>
####특정 키의 값 불러오기<br/>
특정 키의 값을 불러올때는 get함수를 사용<br/>
ex) data.get('a'); --> data는 배열을 가지고있는 변수임<br/>


####깊숙이 위치하는 값 불러오기<br/>
Map내부에 또 Map이 존재하고 그 Map안에 있는 키값을 불러올때는 getIn함수를 사용<br/>
ex) data.getIn(['c','d']);

####값 설정
새 값을 설정할 때는 get대신 set을 사용<br/>
ex) const newData = data.set('a',4); -->객체안의 a의 값을 4로 바꾼다는 뜻<br/>
##set을 한다고해서 데이터가 실제로 변하는 것은 아니다. 주어진 변화를 적용한 새 Map 을 만드는 것임!
실제로 newData === data를 해보면 서로 다른 Map이기 때문에 false를 반환함. 기존 data값은 그대로 남아있고,<br/>
변화가 적용된 데이터를 newData에 저장하는 것이다.<br/>
####깊숙히 위치하는 값 수정
깊숙이 위치하는 값을 수정할때는 setIn을 사용. 이때 내부에 있는 객체들도 Map형태여야만 사용할수 있다는 점에 주의!<br/>
const newData = data.setIn(['c','d'], 10);<br/>

####여러값 동시에 설정
값 여러개를 동시에 설정 해야할때는 mergeIn을 사용. 예를 들어 c값과 d값, c값과 e값을 동시에 바꾸어야할때<br>
const newData = data.mergeIn(['c'], { d: 10, e: 10});<br/>
이렇게 mergeIn을 사용하면 c안에 들어있는 f값은 그대로 유지하면서 d값과 e값만 변경<br/>
const newData = data.setIn(['c', 'd'], 10)<br/>
                .setIn(['c','e'], 10);도 가능<br/>
set을 여러번할지, 아니면 merge를 할지는 그때그때 상황에 맞추면 된다. 성능상으로는 set을 여러번 하는것이 더빠르다!<br/>
--------------------------------------------------
List
=======================================
List는 Immutable 데이터 구조로 배열 대신사용. 배열과 동일하게 <br/>
map, filter, sort, push, pop 함수를 내장하고 있다. 이 내장 함수를 실행하면 List자체를 변경하는 것이 아니라<br/>
새로운 List를 반환한다!!!!<br/>
또 리액트 컴포넌트는 List데이터 구조와 호환되기 때문에 map함수를 사용하여 데이터가 들어있는<br/>
List를 컴포넌트 List로 변환하여 JSX에서 보여주어도 제대로 렌더링된다!<br/>
####생성
List는 다음과 같이 만듬<br/>
const { List } = Immutable;<br/>
const list = List([0,1,2,3,4]);<br/>
객체들의 List를 만들어야 할 때는 다음과 같이 객체들을 Map으로 만들어야 추후 get과 set을 사용할수있음.<br/>
const list = List([<br/>
    Map({ value: 1}),<br/>
    Map({ value: 2})<br/>
]);<br/>

const list2 = fromJS([<br/>
    { value : 1},<br/>
    { value : 2}<br/>
]);<br/>
도 가능<br/>
fromJS를 사용하면 내부 배열은 List로 만들고, 내부 객체는 Map으로 만든다.<br/>
그리고 Map과 마찬가지로 List도 toJS를 사용하여 일반배열로 변환가능.
-----------------------------
Ducks파일 구조?
=========================
액션타입, 액션 생성 함수, 리듀서를 모두 한 파일에서 모듈화 하여 관리하면 어떨까? 라는 아이디어로 만든 파일구조<br/>
####규칙
1. export default를 이용하여 리듀서를 내보내야한다!
2. export를 이용하여 액션 생성 함수를 내보내야 합니다.
3. 액션 타입 이름은 npm-module-or-app/reducer/ACTION_TYPE형식으로 만들어야 한다.
4. 외부 리듀서에서 모듈의 액션 타입이 필요할 때는 액션 타입을 내보내도 된다.
Ducks 구조를 사용할때는 이 몇가지 규칙을 준수한다.
-----------------------------------------


